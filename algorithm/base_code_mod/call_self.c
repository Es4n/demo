#include <stdio.h>
/*
    递归思路：
    最后返回的结果是：第1个字符往后都是无空格字符串
    第1个字符往后都是无空格字符串就需要：第1个字符不是空格，然后第1 + 1个字符往后都是无空格字符串
    第1 + 1个字符往后都是无空格字符串就需要：第1 + 1个字符不是空格，然后第1 + 2个字符往后都是无空格字符串
    第1 + 2个字符往后都是无空格字符串就需要：第1 + 2个字符不是空格，然后第1 + 3个字符往后都是无空格字符串
    。。。
    第1 + n个字符往后都是无空格字符串就需要：第1 + n个字符不是空格，然后第1 + （n+1）个字符往后都是无空格字符串
    如果第1 + n个字符是最后的字符，那么就递归完成

    如果第n个字符为空格如何？
    就将第n+1个字符开头的无空格字符往前复制

    逻辑如下：
    如果第一个字符是结束符，则该字符串是无空格字符串，将此无空格字符串返回到上一层递归
    如果第一个字符不是空格，就检查第二个字符开始往后的字符串
    如果第一个字符是空格，那就拿第二个字符开始往后的无空格字符串，整体前移一个位置，覆盖掉第一个空格

    往前移动实现方法：
    往后遍历每一个字符，每一个字符都往start位置复制，复制后start位置后移1，move位置后移1，直到结束符为止
    输入情况如下：
    如果start处结束符，将结束符复制到start位置，退出
    如果start处是非结束符，将move处的字符往start处复制，复制完成后start后移1，move后移1
    
*/

int del(char *str,int start)
{
    if(str[start] == '\0')  //如果第一个字符是结束符，则该字符串是无空格字符串，将此无空格字符串返回到上一层递归
    {
        return start;
    }else if(str[start] != ' ')  //如果第一个字符不是空格，就检查第二个字符开始往后的字符串
    {
        del(str,start + 1);
        return start;
    }else  //如果第一个字符是空格，那就拿第二个字符开始往后的无空格字符串，整体前移一个位置，覆盖掉第一个空格
    {
        //移动用的下标
        int move = start + 1;
        
        //拿下一字符开始往后的无空格字符
        del(str,start + 1);

        //下一字符开始往后的无空格字符整体往前移
        while(1)
        {
            if(str[move] == '\0')
            {
                str[start] = str[move];
                return start;
            }else
            {
                str[start++] = str[move++];
            }
        }
    }
}

int main()
{
    //输入的字符串
    char str[] = "    a bc d   efg";

    del(str,0);

    printf("%s\n",str);

    return 0;

}
